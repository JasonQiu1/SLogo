package tool;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;

/**
 * Generates the Expression class in the coderunner package. Easy to add and modify different types
 * of expressions.
 *
 * @author Jason Qiu
 */
class ExpressionClassGenerator {

  private static final String[] TARGET_PATH =
      {".", "src", "main", "java", "slogo", "model", "coderunner"}; // file path in source
  private static final String EXPRESSION_CLASS_NAME = "Expression";
  private static final String EXPRESSIONS = // all internal expression classes to generate
      """
              Number
              double value
              
              Binary
              Token operator
              Expression left
              Expression right
              
              Unary
              Token operator
              Expression right
              
              Variable
              Token name
              
              SetVariable
              Token name
              Expression value
              
              DefineCommand
              Token name
              List<Token> parameters
              List<Expression> body
              
              Call
              Token commandName
              
              Block
              List<Expression> body
          """;
  private static final String PACKAGE = "package slogo.model.coderunner;";
  private static final String IMPORTS = """
      import java.util.List;""";
  private static final String CLASS_HEADER = """
      /**
       * Represents all interpretable objects.
       *
       * @author Jason Qiu (GENERATED BY ExpressionClassGenerator.java)
       */""";
  private static final String CLASS_DECLARATION = """
      public abstract class Expression {""";
  private static final String CLASS_DEFINITION_PREFACE = "  abstract double accept(Visitor visitor);";
  private static final String CLASS_FOOTER = """
        }""";

  public static void main(String[] args) throws IOException {
    String[] expressionBlocks = EXPRESSIONS.split("\n\n");
    String[][] expressionDefinitions = new String[expressionBlocks.length][];
    String[] expressionNames = new String[expressionBlocks.length];
    for (int i = 0; i < expressionBlocks.length; i++) {
      expressionDefinitions[i] = expressionBlocks[i].split("\n");
      // strip whitespace
      for (int j = 0; j < expressionDefinitions[i].length; j++) {
        expressionDefinitions[i][j] = expressionDefinitions[i][j].trim();
      }
      expressionNames[i] = expressionDefinitions[i][0];
    }

    writeFile(createVisitorClassString(expressionNames),
        createClassDefinitionsString(expressionDefinitions));
  }

  private static String createVisitorClassString(String[] expressionNames) {
    StringBuilder visitorClass = new StringBuilder("  interface Visitor {\n");
    for (String expressionName : expressionNames) {
      visitorClass.append("\n");
      visitorClass.append(createVisitMethodString(expressionName));
      visitorClass.append("\n");
    }
    visitorClass.append("  }");
    return visitorClass.toString();
  }

  private static String createVisitMethodString(String expressionName) {
    StringBuilder visitMethod = new StringBuilder();
    visitMethod.append("    double visit");
    visitMethod.append(expressionName);
    visitMethod.append("(");
    visitMethod.append(expressionName);
    visitMethod.append(" expression);");
    return visitMethod.toString();
  }

  private static String createClassDefinitionsString(String[][] expressionDefinitions) {
    StringBuilder classDefinitions = new StringBuilder();
    for (String[] expressionDefinition : expressionDefinitions) {
      classDefinitions.append("\n");
      classDefinitions.append(createClassDefinitionString(expressionDefinition));
      classDefinitions.append("\n");
    }

    return classDefinitions.toString();
  }

  private static String createClassDefinitionString(String[] expressionDefinition) {
    StringBuilder classDefinition = new StringBuilder();
    String className = expressionDefinition[0];
    String[][] fields = new String[expressionDefinition.length - 1][2];
    for (int i = 0; i < fields.length; i++) {
      fields[i] = expressionDefinition[i + 1].split(" ");
    }
    // class declaration
    classDefinition.append("  public static class ");
    classDefinition.append(className);
    classDefinition.append(" extends ");
    classDefinition.append(EXPRESSION_CLASS_NAME);
    classDefinition.append(" {\n");
    classDefinition.append("\n");
    // constructor
    classDefinition.append("    ");
    classDefinition.append(className);
    classDefinition.append("(");
    for (String[] field : fields) {
      classDefinition.append(field[0]);
      classDefinition.append(" ");
      classDefinition.append(field[1]);
      classDefinition.append(", ");
    }
    classDefinition.delete(classDefinition.length() - 2, classDefinition.length()); // trim last comma
    classDefinition.append(") {");
    classDefinition.append("\n");
    // constructor body
    for (String[] field : fields) {
      classDefinition.append("      this.");
      classDefinition.append(field[1]);
      classDefinition.append(" = ");
      classDefinition.append(field[1]);
      classDefinition.append(";\n");
    }
    classDefinition.append("    }\n");
    classDefinition.append("\n");
    // accept method override
    classDefinition.append("    @Override\n");
    classDefinition.append("    double accept(Visitor visitor) {\n");
    classDefinition.append("      return visitor.visit");
    classDefinition.append(className);
    classDefinition.append("(this);\n");
    classDefinition.append("    }\n");
    classDefinition.append("\n");
    // getters
    for (String[] field : fields) {
      classDefinition.append("    ");
      classDefinition.append(field[0]);
      classDefinition.append(" get");
      classDefinition.append(field[1].substring(0, 1).toUpperCase());
      classDefinition.append(field[1].substring(1));
      classDefinition.append("() {\n");
      classDefinition.append("      return ");
      classDefinition.append(field[1]);
      classDefinition.append(";\n");
      classDefinition.append("    }\n");
      classDefinition.append("\n");
    }
    // field declarations
    for (String[] field : fields) {
      classDefinition.append("    private final ");
      classDefinition.append(field[0]);
      classDefinition.append(" ");
      classDefinition.append(field[1]);
      classDefinition.append(";\n");
    }
    classDefinition.append("  }");
    return classDefinition.toString();
  }

  private static void writeFile(String visitorClass, String classDefinitions) throws IOException {
    File classFile =
        new File(String.join(File.separator, TARGET_PATH), EXPRESSION_CLASS_NAME + ".java");
    System.out.println(classFile.getCanonicalPath());
    try (PrintWriter printWriter = new PrintWriter(classFile, StandardCharsets.UTF_8)) {
      printWriter.println(PACKAGE);
      printWriter.println();
      printWriter.println(IMPORTS);
      printWriter.println();
      printWriter.println(CLASS_HEADER);
      printWriter.println();
      printWriter.println(CLASS_DECLARATION);
      printWriter.println();
      printWriter.println(visitorClass);
      printWriter.println();
      printWriter.println(CLASS_DEFINITION_PREFACE);
      printWriter.println();
      printWriter.println(classDefinitions);
      printWriter.println(CLASS_FOOTER);
    } catch(IOException e) {
      System.out.println("IO error with file: " + e.getMessage());
    }
  }
}
