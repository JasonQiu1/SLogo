package slogo.model.coderunner;

import java.util.List;

/**
 * Represents all interpretable objects.
 *
 * @author Jason Qiu (GENERATED BY ExpressionClassGenerator.java)
 */

public abstract class Expression {

  interface Visitor {

    double visitNumber(Number expression);

    double visitBinary(Binary expression);

    double visitUnary(Unary expression);

    double visitVariable(Variable expression);

    double visitCall(Call expression);

    double visitBlock(Block expression);

    double visitMake(Make expression);

    double visitFor(For expression);

    double visitIfElse(IfElse expression);

    double visitTo(To expression);

    double visitTurtles(Turtles expression);

    double visitTell(Tell expression);

    double visitAsk(Ask expression);

    double visitAskWith(AskWith expression);
  }

  abstract double accept(Visitor visitor);


  public static class Number extends Expression {

    Number(double value) {
      this.value = value;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitNumber(this);
    }

    double getValue() {
      return value;
    }

    private final double value;
  }

  public static class Binary extends Expression {

    Binary(Token operator, Expression left, Expression right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitBinary(this);
    }

    Token getOperator() {
      return operator;
    }

    Expression getLeft() {
      return left;
    }

    Expression getRight() {
      return right;
    }

    private final Token operator;
    private final Expression left;
    private final Expression right;
  }

  public static class Unary extends Expression {

    Unary(Token operator, Expression right) {
      this.operator = operator;
      this.right = right;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitUnary(this);
    }

    Token getOperator() {
      return operator;
    }

    Expression getRight() {
      return right;
    }

    private final Token operator;
    private final Expression right;
  }

  public static class Variable extends Expression {

    Variable(Token name) {
      this.name = name;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitVariable(this);
    }

    Token getName() {
      return name;
    }

    private final Token name;
  }

  public static class Call extends Expression {

    Call(Token commandName) {
      this.commandName = commandName;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitCall(this);
    }

    Token getCommandName() {
      return commandName;
    }

    private final Token commandName;
  }

  public static class Block extends Expression {

    Block(List<Expression> body) {
      this.body = body;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitBlock(this);
    }

    List<Expression> getBody() {
      return body;
    }

    private final List<Expression> body;
  }

  public static class Make extends Expression {

    Make(Token variable, Expression value) {
      this.variable = variable;
      this.value = value;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitMake(this);
    }

    Token getVariable() {
      return variable;
    }

    Expression getValue() {
      return value;
    }

    private final Token variable;
    private final Expression value;
  }

  public static class For extends Expression {

    For(Token iterator, Expression start, Expression end, Expression increment, Expression body) {
      this.iterator = iterator;
      this.start = start;
      this.end = end;
      this.increment = increment;
      this.body = body;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitFor(this);
    }

    Token getIterator() {
      return iterator;
    }

    Expression getStart() {
      return start;
    }

    Expression getEnd() {
      return end;
    }

    Expression getIncrement() {
      return increment;
    }

    Expression getBody() {
      return body;
    }

    private final Token iterator;
    private final Expression start;
    private final Expression end;
    private final Expression increment;
    private final Expression body;
  }

  public static class IfElse extends Expression {

    IfElse(Expression predicate, Expression trueBranch, Expression falseBranch) {
      this.predicate = predicate;
      this.trueBranch = trueBranch;
      this.falseBranch = falseBranch;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitIfElse(this);
    }

    Expression getPredicate() {
      return predicate;
    }

    Expression getTrueBranch() {
      return trueBranch;
    }

    Expression getFalseBranch() {
      return falseBranch;
    }

    private final Expression predicate;
    private final Expression trueBranch;
    private final Expression falseBranch;
  }

  public static class To extends Expression {

    To(Token commandName, List<Token> parameters, Expression body) {
      this.commandName = commandName;
      this.parameters = parameters;
      this.body = body;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitTo(this);
    }

    Token getCommandName() {
      return commandName;
    }

    List<Token> getParameters() {
      return parameters;
    }

    Expression getBody() {
      return body;
    }

    private final Token commandName;
    private final List<Token> parameters;
    private final Expression body;
  }

  public static class Turtles extends Expression {

    Turtles() {
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitTurtles(this);
    }

  }

  public static class Tell extends Expression {

    Tell(List<Expression> ids) {
      this.ids = ids;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitTell(this);
    }

    List<Expression> getIds() {
      return ids;
    }

    private final List<Expression> ids;
  }

  public static class Ask extends Expression {

    Ask(List<Expression> ids, Expression body) {
      this.ids = ids;
      this.body = body;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitAsk(this);
    }

    List<Expression> getIds() {
      return ids;
    }

    Expression getBody() {
      return body;
    }

    private final List<Expression> ids;
    private final Expression body;
  }

  public static class AskWith extends Expression {

    AskWith(Expression predicate, Expression body) {
      this.predicate = predicate;
      this.body = body;
    }

    @Override
    double accept(Visitor visitor) {
      return visitor.visitAskWith(this);
    }

    Expression getPredicate() {
      return predicate;
    }

    Expression getBody() {
      return body;
    }

    private final Expression predicate;
    private final Expression body;
  }

}
