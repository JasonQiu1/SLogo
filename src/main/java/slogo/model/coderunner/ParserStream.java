package slogo.model.coderunner;

import java.util.ArrayList;
import java.util.List;
import slogo.model.api.exception.coderunner.RunCodeError;
import slogo.model.coderunner.Expression.Block;
import slogo.model.coderunner.Expression.Make;
import slogo.model.command.library.Left;

/**
 * Parses a stream of tokens into a stream of interpretable expressions.
 *
 * @author Jason Qiu
 */
class ParserStream implements Parser {

  ParserStream(Lexer lexer) {
    this.lexer = lexer;
    previousToken = null;
    currentToken = null;
    nextToken();
  }

  @Override
  public Expression parseNext() throws RunCodeError {
    return expression();
  }

  private Expression expression() {
    return term();
  }

  private Expression term() {
    Expression expression = factor();
    if (match(TokenType.PLUS, TokenType.MINUS)) {
      Token operator = previousToken;
      Expression right = factor();
      return new Expression.Binary(operator, expression, right);
    }
    return expression;
  }

  private Expression factor() {
    Expression expression = comparison();
    if (match(TokenType.STAR, TokenType.FORWARD_SLASH, TokenType.PERCENT)) {
      Token operator = previousToken;
      Expression right = comparison();
      return new Expression.Binary(operator, expression, right);
    }
    return expression;
  }

  private Expression comparison() {
    Expression expression = unary();
    if (match(TokenType.EQUAL_TO, TokenType.NOT_EQUAL_TO, TokenType.GREATER_EQUAL_TO,
        TokenType.LESS_EQUAL_TO, TokenType.GREATER_THAN, TokenType.LESS_THAN)) {
      Token operator = previousToken;
      Expression right = unary();
      return new Expression.Binary(operator, expression, right);
    }
    return expression;
  }

  private Expression unary() {
    Expression expression = literal();
    if (match(TokenType.TILDA)) {
      return new Expression.Unary(previousToken, expression);
    }
    return expression;
  }

  private Expression literal() {
    Expression expression = keywords();
    if (expression != null) {
      return expression;
    }
    if (match(TokenType.VARIABLE)) {
      return new Expression.Variable(previousToken);
    }
    if (match(TokenType.NUMBER)) {
      return new Expression.Number((double) previousToken.literal());
    }
    return expression;
  }

  // keywords expressions
  // MAKE, REPEAT, DOTIMES, FOR, IF, IFELSE, TO, ID, TURTLES, TELL, ASK, ASKWITH
  private Expression keywords() {
    Block expression = block();

    if (match(TokenType.MAKE)) {
      Token variable = consume(TokenType.VARIABLE);
      Expression value = expression();
      return new Make(variable, value);
    }

    if (match(TokenType.REPEAT)) {
      Expression times = expression();
      Block body = consumeBlock();
      Token plusToken = new Token(TokenType.PLUS, null, -1, "autogenerated by parser");
      Expression end = new Expression.Binary(plusToken, times, new Expression.Number(1));
      return new Expression.For(
          new Token(TokenType.VARIABLE, "repcount", -1, "autogenerated by parser"),
          new Expression.Number(1), end, new Expression.Number(1), body);
    }

    if (match(TokenType.DOTIMES)) {
      consume(TokenType.LEFT_SQUARE_BRACKET);
      consume(TokenType.VARIABLE);
      Token variableToken = previousToken;
      Expression limit = expression();
      consume(TokenType.RIGHT_SQUARE_BRACKET);

      Block body = consumeBlock();

      Token plusToken = new Token(TokenType.PLUS, null, -1, "autogenerated by parser");
      Expression end = new Expression.Binary(plusToken, limit, new Expression.Number(1));
      return new Expression.For(variableToken, new Expression.Number(1), end,
          new Expression.Number(1), body);
    }

    if (match(TokenType.FOR)) {
      consume(TokenType.LEFT_SQUARE_BRACKET);
      consume(TokenType.VARIABLE);
      Token variableToken = previousToken;
      Expression start = expression();
      Expression end = expression();
      Expression increment = expression();
      consume(TokenType.RIGHT_SQUARE_BRACKET);

      Block body = consumeBlock();

      return new Expression.For(variableToken, start, end, increment, body);
    }

    if (match(TokenType.IF)) {
      Expression predicate = blockUntil(TokenType.LEFT_SQUARE_BRACKET);
      Expression trueBranch = consumeBlock();
      return new Expression.IfElse(predicate, trueBranch, null);
    }

    if (match(TokenType.IFELSE)) {
      Expression predicate = blockUntil(TokenType.LEFT_SQUARE_BRACKET);
      Expression trueBranch = consumeBlock();
      Expression falseBranch = consumeBlock();
      return new Expression.IfElse(predicate, trueBranch, falseBranch);
    }

    if (match(TokenType.TO)) {
      consume(TokenType.COMMAND);
      Token commandName = previousToken;
      List<Token> parameters = new ArrayList<>();
      consume(TokenType.LEFT_SQUARE_BRACKET);
      while (match(TokenType.VARIABLE)) {
        parameters.add(previousToken);
      }
      consume(TokenType.RIGHT_SQUARE_BRACKET);
      Block body = consumeBlock();

      return new Expression.To(commandName, parameters, body);
    }

    if (match(TokenType.TURTLES)) {
      return new Expression.Turtles();
    }

    if (match(TokenType.TELL)) {
      Block ids = consumeBlock();
      return new Expression.Tell(ids.getBody());
    }

    if (match(TokenType.ASK)) {
      Block ids = consumeBlock();
      Block body = consumeBlock();
      return new Expression.Ask(ids.getBody(), body);
    }

    if (match(TokenType.ASKWITH)) {
      Expression predicate = expression();
      Block body = consumeBlock();
      return new Expression.AskWith(predicate, body);
    }

    if (match(TokenType.COMMAND)) {
      return new Expression.Call(previousToken);
    }

    return expression;
  }

  private Block blockUntil(TokenType limiter) {
    List<Expression> body = new ArrayList<>();
    while (!check(limiter)) {
      body.add(expression());
    }
    return new Block(body, previousToken.line());
  }

  private Block block() {
    if (match(TokenType.LEFT_SQUARE_BRACKET)) {
      List<Expression> body = new ArrayList<>();
      while (!match(TokenType.RIGHT_SQUARE_BRACKET)) {
        body.add(expression());
      }
      return new Block(body, previousToken.line());
    }
    return null;
  }

  private Block consumeBlock() {
    consume(TokenType.LEFT_SQUARE_BRACKET);
    List<Expression> body = new ArrayList<>();
    while (!check(TokenType.RIGHT_SQUARE_BRACKET)) {
      body.add(expression());
    }
    consume(TokenType.RIGHT_SQUARE_BRACKET);
    return new Block(body, previousToken.line());
  }

  private boolean check(TokenType... types) {
    for (TokenType type : types) {
      if (currentToken.type() == type) {
        return true;
      }
    }
    return false;
  }

  private Token consume(TokenType type) {
    if (!match(type)) {
      throw Util.createError("expectedDifferentToken", currentToken);
    }
    return previousToken;
  }

  private boolean match(TokenType... types) {
    for (TokenType type : types) {
      if (currentToken.type() == type) {
        nextToken();
        return true;
      }
    }
    return false;
  }

  private boolean isAtEnd() {
    return previousToken != null && previousToken.type() == TokenType.EOF;
  }

  private Token nextToken() {
    previousToken = currentToken;
    currentToken = lexer.nextToken();
    if (isAtEnd()) {
      throw Util.createError("expectedTokens", currentToken);
    }
    return currentToken;
  }

  private final Lexer lexer;
  private Token previousToken;
  private Token currentToken;
}
